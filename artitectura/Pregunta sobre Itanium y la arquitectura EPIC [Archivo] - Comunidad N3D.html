<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0068)http://foro.noticias3d.com/vbulletin/archive/index.php?t-329580.html -->
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	
	<meta name="keywords" content="tiempo, epic, ejecucion, pregunta, procesador, arquitectura, planificacion, compilacion, realizar, planificaion, otro, pues, pero, rapido, compilador, fallo, vliw, tiene, itanium, librarse, relizar, tener, explicado, libera, sera, orange, tanto, procesadores, imaginaos, decir, primero, iguales, aqui, gracias, hacer, porque, exactamente, realizarla, segundo, igual, realiza, tenga, cual, bien, sabe, alguien, aunque, haber, estudiado, tambien">
	<meta name="description" content="Hola buenas 
  
Queria haceros una pregunta a los ingenieros informaticos del foro (aunque si alguien lo sabe sin haber estudiado bienvenido sea tambien ;) ) 
  
La arquitectura EPIC en la que se basa Itanium, proviene de la arquitectura VLIW, pero sin uno de los dos grandes fallos que tenia esta ultima, el fallo de la retrocompatibilidad (el fallo de que los compiladores tienen que ser muy complicados, sigue en EPIC). 
  
Pues bien con EPIC (y VLIW), es el compilador, en tiempo de compilacion,">
	
	<title> Pregunta sobre Itanium y la arquitectura EPIC [Archivo]  - Comunidad N3D</title>
	<link rel="stylesheet" type="text/css" href="./Pregunta sobre Itanium y la arquitectura EPIC [Archivo] - Comunidad N3D_files/archive.css">
</head>
<body>
<div class="pagebody">
<div id="navbar"><a href="http://foro.noticias3d.com/vbulletin/archive/index.php?s=7c3563c71c548b481831b34070559b80">Comunidad N3D</a> &gt; <a href="http://foro.noticias3d.com/vbulletin/archive/index.php?f-4.html&amp;s=7c3563c71c548b481831b34070559b80">Hardware</a> &gt; <a href="http://foro.noticias3d.com/vbulletin/archive/index.php?f-39.html&amp;s=7c3563c71c548b481831b34070559b80">Procesadores</a> &gt;  Pregunta sobre Itanium y la arquitectura EPIC</div>
<hr>
<div class="pda"><a href="http://foro.noticias3d.com/vbulletin/archive/index.php?t-329580.html&amp;s=7c3563c71c548b481831b34070559b80&amp;pda=1" rel="nofollow">PDA</a></div>
<p class="largefont">Ver la versión completa : <a href="http://foro.noticias3d.com/vbulletin/showthread.php?t=329580&amp;s=7c3563c71c548b481831b34070559b80">Pregunta sobre Itanium y la arquitectura EPIC</a></p>
<hr>
<div class="floatcontainer">  </div><br>
<div class="post"><div class="posttop"><div class="username">Forospc1</div><div class="date">23/05/2010, 11:02</div></div><div class="posttext">Hola buenas<br>
 <br>
Queria haceros una pregunta a los ingenieros informaticos del foro (aunque si alguien lo sabe sin haber estudiado bienvenido sea tambien ;) )<br>
 <br>
La arquitectura EPIC en la que se basa Itanium, proviene de la arquitectura VLIW, pero sin uno de los dos grandes fallos que tenia esta ultima, el fallo de la retrocompatibilidad (el fallo de que los compiladores tienen que ser muy complicados, sigue en EPIC).<br>
 <br>
Pues bien con EPIC (y VLIW), es el compilador, en tiempo de compilacion, y no el procesador, en tiempo de ejecucion, el que planifica que instrucciones pueden ejecutarse al mismo tiempo y cuales no.<br>
 <br>
Pues aqui mi pregunta:<br>
 <br>
Al relizar esa planificacion en tiempo de compilacion y no en tiempo de ejecucion, ¿se libera al procesador de ese tiempo, y por lo tanto es mas rapido que otro procesador igual pero que si tenga que realizar esa planificaion en tiempo de ejecucion?<br>
 <br>
Es decir, imaginaos dos procesadores exactamente iguales, uno EPIC y otro "no EPIC", el primero no tiene que hacer esa planificacion en tiempo de ejecucion (porque la realiza el compilador en tiempo de compilacion) y el segundo si tiene que realizarla en tiempo de ejecucion, cual sera mas rapido, ¿el EPIC por librarse del tiempo de esa planificaion o el "no EPIC" por si tener que realizar esa planificacion en tiempo de ejecucion?<br>
 <br>
No se si me he explicado :orange:<br>
 <br>
Gracias!</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Moiquintanillas</div><div class="date">23/05/2010, 18:11</div></div><div class="posttext">No hagas post porque si, ni tengas tanta prisa.<br>
<br>
Hoy es domingo, mucha gente no esta en el foro y el caso tambien es que sepan de que estas hablando. Personalmente npi.</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Forospc1</div><div class="date">23/05/2010, 19:45</div></div><div class="posttext">No hagas post porque si, ni tengas tanta prisa.<br>
 <br>
Hoy es domingo, mucha gente no esta en el foro y el caso tambien es que sepan de que estas hablando. Personalmente npi.<br>
 <br>
Ok muchas gracias.</div></div><hr>


<div class="post"><div class="posttop"><div class="username">ElKeBusk</div><div class="date">23/05/2010, 20:32</div></div><div class="posttext">Hola buenas<br>
 <br>
Queria haceros una pregunta a los ingenieros informaticos del foro (aunque si alguien lo sabe sin haber estudiado bienvenido sea tambien ;) )<br>
 <br>
La arquitectura EPIC en la que se basa Itanium, proviene de la arquitectura VLIW, pero sin uno de los dos grandes fallos que tenia esta ultima, el fallo de la retrocompatibilidad (el fallo de que los compiladores tienen que ser muy complicados, sigue en EPIC).<br>
 <br>
Pues bien con EPIC (y VLIW), es el compilador, en tiempo de compilacion, y no el procesador, en tiempo de ejecucion, el que planifica que instrucciones pueden ejecutarse al mismo tiempo y cuales no.<br>
 <br>
Pues aqui mi pregunta:<br>
 <br>
Al relizar esa planificacion en tiempo de compilacion y no en tiempo de ejecucion, ¿se libera al procesador de ese tiempo, y por lo tanto es mas rapido que otro procesador igual pero que si tenga que realizar esa planificaion en tiempo de ejecucion?<br>
 <br>
Es decir, imaginaos dos procesadores exactamente iguales, uno EPIC y otro "no EPIC", el primero no tiene que hacer esa planificacion en tiempo de ejecucion (porque la realiza el compilador en tiempo de compilacion) y el segundo si tiene que realizarla en tiempo de ejecucion, cual sera mas rapido, ¿el EPIC por librarse del tiempo de esa planificaion o el "no EPIC" por si tener que realizar esa planificacion en tiempo de ejecucion?<br>
 <br>
No se si me he explicado :orange:<br>
 <br>
Gracias!<br>
Sin saber qué es Itanium y la arquitectura EPIC, en principio todo programa optimizado para un procesador es más rápido que uno no optimizado, que es lo que deduzco de lo que has dicho. La planificación en tiempo de compilación es una optimización del correspondiente programa.<br>
<br>
Salu2 :)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Forospc1</div><div class="date">23/05/2010, 20:40</div></div><div class="posttext">Sin saber qué es Itanium y la arquitectura EPIC, en principio todo programa optimizado para un procesador es más rápido que uno no optimizado, que es lo que deduzco de lo que has dicho. La planificación en tiempo de compilación es una optimización del correspondiente programa.<br>
 <br>
Salu2 :)<br>
 <br>
Gracias, pero, no es a lo que me referia, pero gracias de todos modos :orange:</div></div><hr>


<div class="post"><div class="posttop"><div class="username">ElKeBusk</div><div class="date">23/05/2010, 21:17</div></div><div class="posttext">Pues como no lo expliques mejor no veo yo a qué otra cosa te puedes referir. Es evidente, tal y como lo has explicado, que la planificación es una optimizacion del código de los programas (los que sean) y por tanto todo programa que esté preplanificado irá más rápido que uno que no lo esté (da igual que el procesador sea EPIC o no, el problema del no-EPIC es que, por lo que deduzco, no podrá ejecutar codigo no preplanificado).<br>
<br>
Salu2 :)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">oMega_3097</div><div class="date">23/05/2010, 21:35</div></div><div class="posttext">Yo creo que está bastante claro :staun: lo difícil es conocer la respuesta.<br>
<br>
Y creo, que no sé, que dependerá. Hay que tener en cuenta que Itanium no es una arquitectura de gran éxito... Algún motivo habrá detrás de eso y quizá éste sea uno de tantos... A saber.<br>
<br>
Creo que el compilador puede desconocer las circunstancias de trabajo del procesador a la hora de ejecutar el código, por lo tanto si el procesador no puede reordenar las instrucciones (cosa que hacen (http://en.wikipedia.org/wiki/Instruction_pipeline), como bien dices, en tiempo de ejecución, normalmente), quizá ahorre un poco de tiempo, pero ante una mala planificación o situaciones desfavorables de trabajo se termine por perder tiempo en esperas, o qué se yo.<br>
<br>
Edito, que acabo de leer la entrada de Wikipedia para VLIW (http://en.wikipedia.org/wiki/Very_long_instruction_word) (y en proceso de lectura de EPIC (http://en.wikipedia.org/wiki/Explicitly_parallel_instruction_computing)), supuestamente sí sería más rápido. El problema (y quizá motivo de su escaso éxito) es que requiere esfuerzo adicional del programador, aparte de no ser compatible con x86, por eso creo que en algunos Itanium se incluyeron partes x86, lo cual es absurdo: VLIW se supone para hacer hardware más sencillo ya que carecería de las partes de planificación de ejecución y todo eso, pero si por eso hay que complicarlo añadiendo partes para permitir la compatibilidad con x86... Carece de sentido, por un lado se simplifica, pero por otro se complica, añadiendo además la mayor complejidad del compilador y además del esfuerzo adicional del programador.<br>
<br>
Aunque no se si más que ayudarte, te estoy liando o simplemente divagando xd</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Morente</div><div class="date">24/05/2010, 22:47</div></div><div class="posttext">Voy a aportar lo poco que sé sobre este tema. No soy ningún experto, sólo espero ayudar a quien inició el hilo (que por cierto, me gustaría saber la razón de su pregunta). Posiblemente los procesadores hayan evolucionado mucho desde que yo estudié estas cosas.<br>
 <br>
<br>
<br>
Al relizar esa planificacion en tiempo de compilacion y no en tiempo de ejecucion, ¿se libera al procesador de ese tiempo, y por lo tanto es mas rapido que otro procesador igual pero que si tenga que realizar esa planificaion en tiempo de ejecucion?<br>
 <br>
Es decir, imaginaos dos procesadores exactamente iguales, uno EPIC y otro "no EPIC", el primero no tiene que hacer esa planificacion en tiempo de ejecucion (porque la realiza el compilador en tiempo de compilacion) y el segundo si tiene que realizarla en tiempo de ejecucion, cual sera mas rapido, ¿el EPIC por librarse del tiempo de esa planificacion o el "no EPIC" por si tener que realizar esa planificacion en tiempo de ejecucion?<br>
 <br>
<br>
 <br>
En primer lugar, una arquitectura VLIW y otra que no lo sea son muy diferentes, y el modelo de ejecución es distinto. Por lo tanto, la pregunta tiene poco sentido así planteada, pues una arquitectura EPIC no se distingue de una arquitectura no EPIC simplemente porque se haga la planificación en tiempo de ejecución.<br>
 <br>
Simplificando, digamos que un procesador convencional ejecuta muchas instrucciones a la vez, en unidades funcionales distintas. Pero claro, el flujo de un programa es secuencial, es decir, aunque luego en el pipeline las instrucciones se desordenen, existen dependencias entre ellas. Es por ello que hay que llevar a cabo una labor de planificación, que esencialmente consiste en esperar a lanzar una instrucción hasta que haya terminado una anterior de la que pudiera depender. Además, algo más que hay que tener en cuenta es el tema de la especulación, es decir, a veces se comienzan a ejecutar instrucciones que posteriormente se descubre que no debían haberse ejecutado, en cuyo caso hay que deshacer el trabajo que hubieran podido realizar estas instrucciones y continuar ejecutando la secuencia correcta.<br>
 <br>
En un procesador del tipo VLIW se empaquetan varias instrucciones convencionales en una macroinstrucción y se ejecutan en paralelo. No se hace ningún control de dependencias, y por tanto ahí si que se gana eficiencia. Además, al ser el compilador el que hace el análisis de dependencias, puede colocar juntas instrucciones muy alejadas en el programa ejecutandose en paralelo, cosa que en el caso estándar nunca se producía.<br>
 <br>
Pero también surgen algunos problemas: en primer lugar, al hacerse la planificación de manera estática, el procesador es muy sensible a fallos de cache; además, el grado de paralelismo que se puede conseguir en un programa es limitado, por lo que quedarán muchos huecos que el compilador no podrá rellenar más que con NOP.<br>
 <br>
Hasta donde yo sé, este tipo de procesadores han encontrado su segmento de mercado en sistemas empotrados que ejecutan siempre el mismo programa, como por ejemplo en dispositivos de audición (sonotones) y similares. En procesadores de propósito general esta arquitectura se ha visto superada por otro tipo de mejoras de los antiguos procesadores segmentados. Incluso cuando se lanzaron los primeros Itanium, era´n más lentos que los Pentium IV de la época.<br>
 <br>
Espero haberte servido de ayuda. Un saludo.</div></div><hr>


<div class="post"><div class="posttop"><div class="username">JaCk0</div><div class="date">25/05/2010, 08:08</div></div><div class="posttext">Los dos aportes son muy interesantes. Ahora a mí me queda la duda de que si con la evolución del Itanium al Itanium 2 (sobretodo en los últimos, los tukwila, con 12 hilos lógicos y 4 cores) ganaron en rendimiento a sus homónimos x86 o simplemente fue una medida disuasoria para evitar gastos de cambios de todo el hardware y software en las empresas que fueron abducidas en un principio por el itanium.</div></div><hr>


<div class="post"><div class="posttop"><div class="username">mk_dir</div><div class="date">25/05/2010, 11:49</div></div><div class="posttext">Los dos aportes son muy interesantes. Ahora a mí me queda la duda de que si con la evolución del Itanium al Itanium 2 (sobretodo en los últimos, los tukwila, con 12 hilos lógicos y 4 cores) ganaron en rendimiento a sus homónimos x86 o simplemente fue una medida disuasoria para evitar gastos de cambios de todo el hardware y software en las empresas que fueron abducidas en un principio por el itanium.<br>
<br>
<br>
Más bien lo segundo, el nuevo core Tukwila (Itanium 93XX) ha tenido una repercusión mínima en el mercado, apenas tendrá presencia como opción de amplicación para las máquinas compatibles. Con la salida de Beckton EX (Xeon 75XX), se puede percivir como Intel deja de lado poco a poco la arquitectura de Itanium para, una vez más, implantar soluciones basadas en X86 en ese entorno.<br>
<br>
PD: Ningún Tukwila (http://techreport.com/discussions.x/18445) tiene 12 threads.<br>
<br>
Saludos</div></div><hr>


<div class="post"><div class="posttop"><div class="username">tamaron</div><div class="date">26/05/2010, 17:48</div></div><div class="posttext">Itanic como lo llaman algunos guiris... No entiendo muy bien cómo después del pastón que se gastaron en I+D están dejando morir a la plataforma. Me gustaría saber cual es la alternativa a x86 que al final se acabará imponiendo...</div></div><hr>


<div class="post"><div class="posttop"><div class="username">ElKeBusk</div><div class="date">26/05/2010, 21:47</div></div><div class="posttext">AMD Fusion, si funciona como sobre el papel se espera que funcione y si con el tiempo evoluciona a lo que parece que tiene intención AMD que evolucione.<br>
<br>
Salu2 :)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">nevermor</div><div class="date">26/05/2010, 21:52</div></div><div class="posttext">Forospc1, no te puedo ayudar en lo que preguntas. Pero si quieres hacerte entender correctamente, y más en algo como lo que preguntas, deberías poner las tildes porque hay algunas que cambian por completo el sentido de lo que expresas, o hay una falta de concordancia que no hay quien se aclare.<br>
No es lo mismo si que sí, que o qué, etc, etc.<br>
<br>
ElKeBusk ¿Qué  tiene que ver aquí AMD y su Fusion?<br>
<br>
Saludos.</div></div><hr>


<div class="post"><div class="posttop"><div class="username">ElKeBusk</div><div class="date">26/05/2010, 21:58</div></div><div class="posttext">ElKeBusk ¿Qué  tiene que ver aquí AMD y su Fusion?<br>
<br>
Saludos.<br>
Respondo lo pregunta de Tamaron sobre cuál puede ser la alternativa a x86.<br>
<br>
Salu2 :)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Forospc1</div><div class="date">26/05/2010, 22:03</div></div><div class="posttext">ElKeBusk ¿Qué tiene que ver aquí AMD y su Fusion?<br>
 <br>
Saludos.<br>
 <br>
+1<br>
 <br>
<br>
AMD Fusion, si funciona como sobre el papel se espera que funcione y si con el tiempo evoluciona a lo que parece que tiene intención AMD que evolucione.<br>
 <br>
Salu2 :) <br>
 <br>
AMD Fusion no es una alternativa a x86...es que es, x86 ;)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">fmvictor</div><div class="date">26/05/2010, 22:22</div></div><div class="posttext">Y por que queréis una alternativa a x86? Con lo bien que va y el soft que hay disponible? Larga vida a x86!. ;)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Fear effect</div><div class="date">26/05/2010, 22:25</div></div><div class="posttext">+1<br>
 <br>
 <br>
 <br>
AMD Fusion no es una alternativa a x86...es que es, x86 ;)<br>
<br>
Para nada es x86, lo sera al principio por aquello de la retrocompativilidad, pero la parte no x86, en teoría debería crecer como un cáncer que al final se comería a la parte x86.<br>
<br>
Estos cambios tienen que ser evolutivos, no se puede cambiar todo el software de la noche a la mañana.<br>
<br>
Intel tiene el proyecto many-core, que es una evolución de su x86, pero seguirá siendo x86 siempre.<br>
<br>
Va ser interesante ver cual se va imponiendo</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Forospc1</div><div class="date">26/05/2010, 22:50</div></div><div class="posttext">Ok<br>
 <br>
Es que mirad:<br>
 <br>
Con VLIW Y EPIC la planificacion del parelelismo (es decir, decidir que instrucciones pueden ejecutarse a la vez y cuales no), la hace el compilador en tiempo de compilacion, en cambio con todas las demas arquitecturas como RISC y CISC (y por tanto todos los x86), esa planificacion la hacen los propios procesadores en tiempo de ejecucion...<br>
 <br>
...de ahi mi pregunta.<br>
 <br>
Gracias a Omega y a Morenete que precticamente han respondido a mi pregunta.<br>
 <br>
Entonces la respuesta es si ¿no?, un procesador EPIC o VLIW si que es mas rapido que un homologo CISC o RISC, ¿verdad?<br>
 <br>
Es decir, a parte de otras diferencias, lo que diferencia a un procesador EPIC de los CISC y RISC, es que los primeros no tienen que realizar esa planificacion en tiempo de ejecucion y los segundos si, es decir, que no hacen ese trabajo de planificacion y entonces por eso EPIC es una arquitectura mas eficiente que CISC y RISC...<br>
 <br>
...¿Es asi?<br>
 <br>
Gracias y saludos!</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Schneider</div><div class="date">26/05/2010, 22:58</div></div><div class="posttext">Hola buenas<br>
 <br>
Queria haceros una pregunta a los ingenieros informaticos del foro (aunque si alguien lo sabe sin haber estudiado bienvenido sea tambien ;) )<br>
 <br>
La arquitectura EPIC en la que se basa Itanium, proviene de la arquitectura VLIW, pero sin uno de los dos grandes fallos que tenia esta ultima, el fallo de la retrocompatibilidad (el fallo de que los compiladores tienen que ser muy complicados, sigue en EPIC).<br>
 <br>
Pues bien con EPIC (y VLIW), es el compilador, en tiempo de compilacion, y no el procesador, en tiempo de ejecucion, el que planifica que instrucciones pueden ejecutarse al mismo tiempo y cuales no.<br>
 <br>
Pues aqui mi pregunta:<br>
 <br>
Al relizar esa planificacion en tiempo de compilacion y no en tiempo de ejecucion, ¿se libera al procesador de ese tiempo, y por lo tanto es mas rapido que otro procesador igual pero que si tenga que realizar esa planificaion en tiempo de ejecucion?<br>
 <br>
Es decir, imaginaos dos procesadores exactamente iguales, uno EPIC y otro "no EPIC", el primero no tiene que hacer esa planificacion en tiempo de ejecucion (porque la realiza el compilador en tiempo de compilacion) y el segundo si tiene que realizarla en tiempo de ejecucion, cual sera mas rapido, ¿el EPIC por librarse del tiempo de esa planificaion o el "no EPIC" por si tener que realizar esa planificacion en tiempo de ejecucion?<br>
 <br>
No se si me he explicado :orange:<br>
 <br>
Gracias!<br>
<br>
Un procesador de tipo VLIW se ahorra una cantidad muy importante de hard dedicado en la cpu no VLIW en intentar paralelizar el flujo de instrucciones.<br>
<br>
Esto es, antes de llegar al back-end y la fase ejecución, un procesador no vliw tiene que dedicarse a "estudiar" las instrucciones a ejecutar, reordenarlas si es posible "adelantarlas" y ejecutarlas así en paralelo, etc.<br>
<br>
Un procesador vliw no tiene que hacer nada de esto porque ya lo ha hecho antes el compilador, de hecho, una cpu de este tipo carece totalmente de este tipo de hard y no es capaz de realizar ejecución especulativa de código alguna.<br>
<br>
TODO ya viene definido en los "paquetes" de instrucciones VLIW que ejecuta dicha cpu.<br>
<br>
Para explicarlo rápidamente:<br>
<br>
<br>
El compilador coge el programa, genera un código de instrucciones, Y además se dedica a estudiar dicho flujo de instrucciones para empaquetar en una instrucción VLIW todas las que pueda del tipo "normal". Esta última parte se puede decir que es el añadido de un compilador para cpus vliw, y lo que vuelve más complejo crear compliadores eficientes para dichas cpus.<br>
<br>
Aquí "normal" define a una operación ejecutada en una unidad de ejecución, una instrucción VLIW en realidad se ejecuta en 1-n unidades de instrucciones, que les tocará a cada una una instrucción sin relación necesaria con las demás empaquetadas en la instrucción VLIW (no tienen porqué ser iguales ni nada similar, de hecho son independientes (requisito)).<br>
<br>
<br>
<br>
Así que con una cpu de éstas tienes dos ventajas:<br>
<br>
1.- Ahorras mucho hard dedicado a planificar la ejecución paralela, hard que puedes "gastar" en aumentar la capacidad de ejecución o el tamaño de cachés de la cpu.<br>
<br>
2.- La compilación del código permite que, en teoría se dedique tiempo "infinito" en comparación a la búsqueda de la ejecución en paralelo "más perfecta" posible en un programa dado, frente a la solución de una cpu normal, que tiene una ventana temporal muy limitada para planificar esto, además de una ventana de instrucciones limitada para estudiar esto.<br>
<br>
Esto permite que un programa compilado para VLIW pueda llegar a ser mucho más eficiente en su ejecución que el mismo programa compilado para una cpu normal y atado a sus técnicas de ejecución especulativa y paralelizaje de instrucciones por hard.<br>
<br>
<br>
<br>
<br>
Los problemas de dichas cpus son la necesidad de compiladores muy complejos capaz de generar código VLIW eficiente (etapa extra de compilación) además de que es difícil que se mantenga la misma eficiencia de ejecución al sacar nuevas generaciones de cpus de una línea dada (si hay cambios en el back end de ejecución, se debería recompilar el código para dicha nueva generación para sacar partido a las novedades, algo "innecesario" en las cpus normales).<br>
<br>
<br>
<br>
Entonces la respuesta es si ¿no?, un procesador EPIC o VLIW si que es mas rapido que un homologo CISC o RISC, ¿verdad?<br>
<br>
NO. Es más simple para una capacidad de ejecución dada, y puede, que no tiene porqué cumplirse, eso sobre todo depende del compilador, ser más eficiente ejecutando código.<br>
<br>
Si un diseño "normal" es muy bueno en la ejecución especulativa y en paralelizar instrucciones, bien puede adelantar el trabajo de un compilador mediocre para el procesador VLIW.</div></div><hr>


<div class="post"><div class="posttop"><div class="username">ElKeBusk</div><div class="date">26/05/2010, 23:31</div></div><div class="posttext">+1<br>
 <br>
 <br>
 <br>
AMD Fusion no es una alternativa a x86...es que es, x86 ;)<br>
No es x86, tiene una parte x86 que son los cores propiamente dichos, pero el procesador consta de una unidad de procesamiento vectorial destinada precisamente a la parelelización de procesos. Se espera que la futura evolución de estos procesadores vaya dando mas y mas peso a esta unidad de procesamiento vectorial y menos a los núcleos x86 de modo que queden como un vestigio destinado a mantener la retrocompatibilidad.<br>
Sin embargo, como digo, es lo que se prevee o se espera de la evolución de fusion, pero que al final sea así no depende sólo de AMD, evidentemente.<br>
Ahora bien, sobre el papel, Fusion es claramente un nuevo camino y una alternativa a x86<br>
El camino que elige INTEL es el SCC que son procesadores con decenas de núcleos x86 (48 mínimo).<br>
<br>
Salu2 :)</div></div><hr>


<div class="post"><div class="posttop"><div class="username">Forospc1</div><div class="date">27/05/2010, 12:58</div></div><div class="posttext">Un procesador de tipo VLIW se ahorra una cantidad muy importante de hard dedicado en la cpu no VLIW en intentar paralelizar el flujo de instrucciones.<br>
 <br>
Esto es, antes de llegar al back-end y la fase ejecución, un procesador no vliw tiene que dedicarse a "estudiar" las instrucciones a ejecutar, reordenarlas si es posible "adelantarlas" y ejecutarlas así en paralelo, etc.<br>
 <br>
Un procesador vliw no tiene que hacer nada de esto porque ya lo ha hecho antes el compilador, de hecho, una cpu de este tipo carece totalmente de este tipo de hard y no es capaz de realizar ejecución especulativa de código alguna.<br>
 <br>
TODO ya viene definido en los "paquetes" de instrucciones VLIW que ejecuta dicha cpu.<br>
 <br>
Para explicarlo rápidamente:<br>
 <br>
 <br>
El compilador coge el programa, genera un código de instrucciones, Y además se dedica a estudiar dicho flujo de instrucciones para empaquetar en una instrucción VLIW todas las que pueda del tipo "normal". Esta última parte se puede decir que es el añadido de un compilador para cpus vliw, y lo que vuelve más complejo crear compliadores eficientes para dichas cpus.<br>
 <br>
Aquí "normal" define a una operación ejecutada en una unidad de ejecución, una instrucción VLIW en realidad se ejecuta en 1-n unidades de instrucciones, que les tocará a cada una una instrucción sin relación necesaria con las demás empaquetadas en la instrucción VLIW (no tienen porqué ser iguales ni nada similar, de hecho son independientes (requisito)).<br>
 <br>
 <br>
 <br>
Así que con una cpu de éstas tienes dos ventajas:<br>
 <br>
1.- Ahorras mucho hard dedicado a planificar la ejecución paralela, hard que puedes "gastar" en aumentar la capacidad de ejecución o el tamaño de cachés de la cpu.<br>
 <br>
2.- La compilación del código permite que, en teoría se dedique tiempo "infinito" en comparación a la búsqueda de la ejecución en paralelo "más perfecta" posible en un programa dado, frente a la solución de una cpu normal, que tiene una ventana temporal muy limitada para planificar esto, además de una ventana de instrucciones limitada para estudiar esto.<br>
 <br>
Esto permite que un programa compilado para VLIW pueda llegar a ser mucho más eficiente en su ejecución que el mismo programa compilado para una cpu normal y atado a sus técnicas de ejecución especulativa y paralelizaje de instrucciones por hard.<br>
 <br>
 <br>
 <br>
 <br>
Los problemas de dichas cpus son la necesidad de compiladores muy complejos capaz de generar código VLIW eficiente (etapa extra de compilación) además de que es difícil que se mantenga la misma eficiencia de ejecución al sacar nuevas generaciones de cpus de una línea dada (si hay cambios en el back end de ejecución, se debería recompilar el código para dicha nueva generación para sacar partido a las novedades, algo "innecesario" en las cpus normales).<br>
 <br>
 <br>
 <br>
 <br>
NO. Es más simple para una capacidad de ejecución dada, y puede, que no tiene porqué cumplirse, eso sobre todo depende del compilador, ser más eficiente ejecutando código.<br>
 <br>
Si un diseño "normal" es muy bueno en la ejecución especulativa y en paralelizar instrucciones, bien puede adelantar el trabajo de un compilador mediocre para el procesador VLIW.<br>
 <br>
Un amigo que es ingeniero informatico, le hice es ta pregunta ayer y me dijo que si, que si un EPIC es homologo que un RISC, el EPIC es mas rapido ya que se salta esa etapa del pipeline.</div></div><hr>

 
<div id="copyright">Powered by vBulletin® Version 4.2.2 Copyright © 2016 vBulletin Solutions, Inc. All rights reserved.</div>
</div>

</body></html>